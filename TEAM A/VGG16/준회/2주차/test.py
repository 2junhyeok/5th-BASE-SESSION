# -*- coding: utf-8 -*-
"""train.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SVsxvD6eAuDG1yfIWIrt-UTBuNWiJ7Ou
"""

# Commented out IPython magic to ensure Python compatibility.
import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms

import torchvision
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from torch.utils.data import DataLoader
from torch.utils import data
import os

# display images
from torchvision import utils
import matplotlib.pyplot as plt
# %matplotlib inline

# utils
import numpy as np
from torchsummary import summary
import time
import copy

transform = transforms.Compose([
    transforms.Resize((32, 32)),
    transforms.ToTensor(),
    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),  # 이미지 정규화
])

test_dataset = datasets.SVHN(root='./data', split='test', download=True, transform=transform)
test_loader = DataLoader(dataset=test_dataset, batch_size=1000, shuffle=False)

def test(model, device, test_loader):
    model.eval()  # 모델을 평가 모드로 설정
    test_loss = 0
    correct = 0
    with torch.no_grad():  # 그래디언트 계산이 필요 없으므로 no_grad 사용
        for data, target in test_loader:
            data, target = data.to(device), target.to(device)  # 데이터를 현재 디바이스로 이동
            output = model(data)  # 모델에 데이터를 전달하여 결과를 계산 (순전파)
            test_loss += nn.CrossEntropyLoss()(output, target).item()  # 배치 손실을 계산하여 누적
            pred = output.argmax(dim=1, keepdim=True)  # 가장 확률이 높은 클래스를 예측 값으로 선택
            correct += pred.eq(target.view_as(pred)).sum().item()  # 예측이 정답과 일치하는 경우의 수를 누적

    test_loss /= len(test_loader.dataset)  # 평균 손실을 계산
    accuracy = 100. * correct / len(test_loader.dataset)  # 정확도 계산

    print(f'\nTest set: Average loss: {test_loss:.4f}, Accuracy: {correct}/{len(test_loader.dataset)} ({accuracy:.0f}%)\n')

# device 설정
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

model = VGG(base_dim=64, num_classes=10).to(device)  # SVHN has 10 classes
optimizer = optim.Adam(model.parameters(), lr=0.001)

epochs = 10
for epoch in range(1, epochs + 1):
    train(model, device, train_loader, optimizer, epoch)
    test(model, device, test_loader)